{
  "hash": "ab72b67802af4d761acbabd28ba0d340",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Neural Networks\"\nsubtitle: \"Classification\"\nformat:\n  revealjs:\n    width: 1200\n    scrollable: false\n    include-in-header: \"math.html\"\n    footer: m408.inqs.info/lectures/3a\n    theme: [default, styles.scss]\n    preview-links: true\n    navigation-mode: vertical\n    controls-layout: edges\n    controls-tutorial: true\n    slide-number: true\n    pointer:\n      pointerSize: 48\n    incremental: false \n    chalkboard:\n      theme: whiteboard\n      chalk-width: 4\nknitr:\n  opts_chunk: \n    echo: true\n    eval: false\n    message: false\n    warnings: false\n    comment: \"#>\" \n    \nrevealjs-plugins:\n  - pointer\n  - verticator\n  \nfilters: \n  - code-fullscreen\n  - reveal-auto-agenda\n\neditor: source\n---\n\n## R Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"torch\")\n# install.packages(\"luz\")\n\nlibrary(torch)\nlibrary(luz) # high-level interface for torch\ntorch_manual_seed(13)\n```\n:::\n\n\n## Data in Python\n\n```python\nimport plotnine\nfrom plotnine.data import penguins\nclean_penguins = (\n    penguins\n        .dropna()\n        .drop(columns=[\"year\"])\n)\n```\n\n# Classification\n\n## Classification\n\nClassification in statistical learning terms indicates predicting a categorical random variable.\n\n## Common Methods\n\n- Naive Bayes Classifier\n\n- Tree-based Methods\n\n- Support Vector Machines\n\n- Logistic/Multinomial regression\n\n- Discriminant Analysis\n\n## Neural Networks\n\n# Loss Functions\n\n## Loss Functions\n\n\n\n\n# Neural Network\n\n# In R\n\n# \n\n## Penguin Data\n\n::: {.panel-tabset}\n\n### Train/Test/Evaluation\n  \n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- penguins |> drop_na()\ntraining <- penguins |> slice_sample(prop = .8)\npre <- penguins |> anti_join(training)\nvalidate <- pre |> slice_sample(prop =  0.5)\ntesting <- pre |> anti_join(validate)\n```\n:::\n\n\n\n\n###  Training\n\n\n::: {.cell}\n\n```{.r .cell-code}\nXtraining <- training |> \n  model.matrix(body_mass ~ . - 1, data = _) |> \n  scale() |> \n  torch_tensor(dtype = torch_float())\n\nYtraining <- training |> \n  select(body_mass) |> \n  as.matrix() |> \n  torch_tensor(dtype = torch_float())\n```\n:::\n\n\n### Validate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nXvalidate <- validate |> \n  model.matrix(body_mass ~ . - 1, data = _) |> \n  scale() |> \n  torch_tensor(dtype = torch_float())\n\nYvalidate <- validate |> \n  select(body_mass) |> \n  as.matrix() |> \n  torch_tensor(dtype = torch_float())\n```\n:::\n\n\n### Testing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nXtesting <- testing |> \n  model.matrix(body_mass ~ . - 1, data = _) |> \n  scale() |> \n  torch_tensor(dtype = torch_float())\n\nYtesting <- testing |> \n  select(body_mass) |> \n  as.matrix() |> \n  torch_tensor(dtype = torch_float())\n```\n:::\n\n\n:::\n\n## Model Description\n\n \n\n::: {.cell}\n\n```{.r .cell-code}\nmodelnn <- nn_module(\n  initialize = function(input_size) {\n    self$hidden1 <- nn_linear(in_features = input_size, \n                              out_features = 20)\n    self$hidden2 <- nn_linear(in_features = 20, \n                              out_features = 10)\n    self$hidden3 <- nn_linear(in_features = 10, \n                              out_features = 5)\n\n    self$output <- nn_linear(in_features = 5, \n                             out_features = 1)\n        \n    self$activation <- nn_relu()\n  },\n  forward = function(x) {\n    x |>  \n      self$hidden1() |>  \n      self$activation() |>  \n      \n      self$hidden2() |>  \n      self$activation() |>  \n\n      self$hidden3() |>  \n      self$activation() |>  \n\n      self$output()\n  }\n)\n```\n:::\n\n\n\n## Optimizer Set Up\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelnn <- modelnn |> \n  setup(\n    loss = nn_mse_loss(), # Used for numerical counts\n    optimizer = optim_rmsprop\n  ) |>\n  set_hparams(input_size = ncol(px))\n```\n:::\n\n\n\n## Fit a Model\n\n::: {.panel-tabset}\n### Fit\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitted <- modelnn |> \n  fit(\n    data = list(Xtraining, Ytraining),\n    epochs = 50, # Can think as number of iterations\n    valid_data = list(Xvalidate, Yvalidate)\n  )\n```\n:::\n\n\n### Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot(fitted)\n```\n:::\n\n\n:::\n\n## Testing Model\n\n::: {.panel-tabset}\n\n### Prediction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnpred <- predict(fitted, Xtesting)\n```\n:::\n\n\n### MAE\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(abs(as.matrix(Ytesting) - as.matrix(npred)))\n```\n:::\n\n\n### Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot(as.matrix(Ytesting), as.matrix(npred),\n     xlab = \"Truth\",\n     ylab = \"Predicted\")\n```\n:::\n\n\n:::\n\n\n",
    "supporting": [
      "5a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}