---
title: |
  Convolutional \
  Neural Networks
subtitle: "Image Classification with CIFAR"
format:
  revealjs:
    width: 1200
    scrollable: false
    include-in-header: "math.html"
    footer: m408.inqs.info/lectures/6a
    theme: [default, styles.scss]
    preview-links: true
    navigation-mode: vertical
    controls-layout: edges
    controls-tutorial: true
    slide-number: true
    pointer:
      pointerSize: 48
    incremental: false 
    chalkboard:
      theme: whiteboard
      chalk-width: 4
knitr:
  opts_chunk: 
    echo: true
    eval: false
    message: false
    warnings: false
    comment: "#>" 
    
revealjs-plugins:
  - pointer
  - verticator
  
filters: 
  - code-fullscreen
  - reveal-auto-agenda

editor: source
---

## R Packages

```r
# install.packages("tidyverse")
# install.packages("torch")
# install.packages("luz")
# install.packages("torchvision")

library(torch)
library(luz) # high-level interface for torch
library(tidyverse)
library(torchvision) # for datasets and image transformation


```

## Python Data

``` python
import torch
import torchvision
import torchvision.transforms as transforms

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

batch_size = 4

trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,
                                          shuffle=True, num_workers=2)

testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,
                                         shuffle=False, num_workers=2)

classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')
```

# Image Classification

## Image Classification

Image classification is the process of having a computer analyzse an image and classify it with a selected category.

## Image Classification

What is this a picture of?

::: fragment
![](img/squirrel.jpg){fig-align="center" width="500"}
:::

## Image Classification

How did you know it was a squirrel?

# Convolutional Neural Networks

## Convolutional Neural Networks

Convolutional Neural Networks became popular in the 2010's with the success of image classification.

::: fragment
The idea is to mimic how a human mind will classify an image. (From an old understanding of neurobiology.)
:::

::: fragment
With the use of convolutional filters, a convolutional neural networks is trained by using a set of images that have been previously classfied.
:::

::: fragment
Once the network is trained, new images can be classified.
:::

## CNN

![Credit: ISLR2](img/islr2/Chapter10/10_6.jpg){fig-align="center"}

## Architecture

![](https://www.embedded.com/wp-content/uploads/2023/06/23026adi-cnn1_f03_thumb.jpg){fig-align="center"}



# Input Data

## Input Data

```{r}
#| eval: true
#| echo: false


library(torch)
library(torchvision)

train_ds <- cifar10_dataset(
  root = "../../",
  train = TRUE,
  download = TRUE,
  transform = transform_to_tensor
)

classes <- c("airplane","automobile","bird","cat","deer",
             "dog","frog","horse","ship","truck")

sample <- train_ds[1]
img <- sample[[1]]$permute(c(2,3,1))
label <- sample[[2]]

plot(as.raster(as.array(img)))

```

## Channels
 
```{r}
#| eval: true
#| echo: false


red   <- img[,,1]
green <- img[,,2]
blue  <- img[,,3]

# Convert to arrays
red   <- as.array(red)
green <- as.array(green)
blue  <- as.array(blue)

make_colored_channel <- function(channel_matrix, color_index) {
  rgb_array <- array(0, dim = c(32, 32, 3))
  rgb_array[,,color_index] <- channel_matrix
  rgb_array
}

par(mfrow = c(1,3))

plot(as.raster(make_colored_channel(red, 1)), main = "Red")

plot(as.raster(make_colored_channel(green, 2)), main = "Green")

plot(as.raster(make_colored_channel(blue, 3)), main = "Blue")

par(mfrow = c(1,1))

```

## Data - Red

```{r}
#| eval: true
#| echo: false

sample$x[1,,] |> as.matrix()
```


# Convolutional Block

## Convolutional Block

A convolutional block (layer) is the process where a matrix (array) of data undergoes the following process.

1. Apply a convolutional filter
2. Fold the channels
3. Pool the data

## Convolution Filter

A Convolution Filter will highlight certain features of an image.

::: fragment
The matching features will contain a large value.
:::

::: fragment
Dismatching features will contain a smaller value.
:::

## Convolution Filter

::: panel-tabset
## Image

$$
\left(
\begin{array}{ccc}
a & b & c \\
d & e & f \\
g & h & i \\
j & k & l 
\end{array}
\right)
$$

## Filter

$$
\left(
\begin{array}{cc}
\alpha & \beta \\
\gamma & \delta
\end{array}
\right)
$$

## Both

$$
\left(
\begin{array}{ccc}
a & b & c \\
d & e & f \\
g & h & i \\
j & k & l 
\end{array}
\right)
*
\left(
\begin{array}{cc}
\alpha & \beta \\
\gamma & \delta
\end{array}
\right)
$$

## Results

$$
\left(
\begin{array}{cc}
a\alpha + b\beta + d\gamma + w\delta & b\alpha + c\beta + e\gamma + f\delta \\
d\alpha + e\beta + g\gamma + h\delta & e\alpha + f\beta + h\gamma + i\delta \\
g\alpha + h\beta + j\gamma + k\delta & h\alpha + i\beta + k\gamma + l\delta
\end{array}
\right)
$$
:::


## Data Example

$$
\left(
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{array}
\right)
*
\left(
\begin{array}{cc}
1/2 & 1/3 \\
1/3 & 1/2
\end{array}
\right)
$$

$$
\left(
\begin{array}{cc}
1/2 + 2/3 + 4/3 + 5/2 & 1 + 1 + 5/3 + 3  \\
2 + 5/3 + 7/3 + 4 & 5/2 + 2 + 8/3 + 9/2
\end{array}
\right)
$$

## Folding

Folding is the process when we combine channels together.
It is common to add the channels together once the convolution filter is applied to each one.

## Folding Example


$$
\left(
\begin{array}{cc}
1 & 2  \\
3 & 4 
\end{array}
\right)
+
\left(
\begin{array}{cc}
5 & 6 \\
7 & 8
\end{array}
\right)
+
\left(
\begin{array}{cc}
9 & 10 \\
11 & 12
\end{array}
\right)
$$


$$
\left(
\begin{array}{cc}
15 & 18 \\
21 & 24
\end{array}
\right)
$$


## Pooling Layers

The act of summarizing a large matrix to a smaller matrix.


## Max Pool

$$
\left[
\begin{array}{cccc}
1 & 3 & 9 & 5 \\
6 & 2 & 3 & 4 \\
1 & 0 & 6 & 4 \\
8 & 4 & 2 & 7
\end{array}
\right] \rightarrow
\left[
\begin{array}{cc}
6 & 9 \\
8 & 7
\end{array}
\right]
$$

## Overall

::: panel-tabset

### Input

$$
\left(
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9  
\end{array}
\right)
$$

$$
\left(
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9  
\end{array}
\right)
$$

$$
\left(
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9  
\end{array}
\right)
$$


### Filter

$$
\left(
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9  
\end{array}
\right)
*
\left(
\begin{array}{cc}
\alpha & \beta \\
\gamma & \delta
\end{array}
\right)
$$

$$
\left(
\begin{array}{ccc}
10 & 20 & 30 \\
40 & 50 & 60 \\
70 & 80 & 90  
\end{array}
\right)
*
\left(
\begin{array}{cc}
\alpha & \beta \\
\gamma & \delta
\end{array}
\right)
$$


$$
\left(
\begin{array}{ccc}
100 & 200 & 300 \\
400 & 500 & 600 \\
700 & 800 & 900  
\end{array}
\right)
*
\left(
\begin{array}{cc}
\alpha & \beta \\
\gamma & \delta
\end{array}
\right)
$$



### Fold

$$
\left(
\begin{array}{cc}
1 & 2  \\
3 & 4 
\end{array}
\right)
+
\left(
\begin{array}{cc}
5 & 6 \\
7 & 8
\end{array}
\right)
+
\left(
\begin{array}{cc}
9 & 10 \\
11 & 12
\end{array}
\right)
$$


$$
\left(
\begin{array}{cc}
15 & 18 \\
21 & 24
\end{array}
\right)
$$

### Pool

$$
\left[
\begin{array}{cccc}
1 & 3 & 9 & 5 \\
6 & 2 & 3 & 4 \\
1 & 0 & 6 & 4 \\
8 & 4 & 2 & 7
\end{array}
\right] \rightarrow
\left[
\begin{array}{cc}
6 & 9 \\
8 & 7
\end{array}
\right]
$$

:::


# CNN Architecture

## Convolve Image

## Flattening

Once the images has been pooled to a select pixels or features. The images are flattened to a set of inputs.

::: fragment
These inputs are used to a traditional neural network to classify an image.
:::

## Training

The CNN is trained by supplying a set of pre-classified images.

::: fragment
The parameters in the convolution filters are estimated using standard techniques.
:::

# R CIFAR Data Analysis

## CIFAR-10 Data

The Canadian Institute for Advanced Research (CIFAR) provides a collection of 60,000 images that are classified in 10 categories. Each image has 32 by 32 pixels.

## CIFAR-10 Classes

::: {.columns}
::: {.column}
- airplanes
- cars
- birds
- cats
- deer
:::
::: {.column}
- dogs
- frogs
- horses
- ships
- trucks
:::
:::

## CIFAR-10 Example

```{r}
#| echo: false
#| eval: true

sample <- train_ds[39]
img <- sample[[1]]$permute(c(2,3,1))
label <- sample[[2]]

plot(as.raster(as.array(img)))

```

## Torch Packages in R

```{r}

library(tidyverse)
library(torch)
library(luz)
library(torchvision)
set.seed(909)
torch_manual_seed(909)

```

## CIFAR-10 Data

```{r}
dir <- "../"


train_ds <- cifar10_dataset(
  root = dir,
  train = TRUE, 
  download = TRUE, 
  transform = transform_to_tensor
)

test_ds <- cifar10_dataset(
  dir, 
  train = FALSE, 
  download = TRUE,
  transform = transform_to_tensor
)

train_dl <- dataloader(train_ds,
  batch_size = 128,
  shuffle = TRUE
)
```

## Convolutional Block


```{r}
conv_block <- nn_module(
  initialize = function(in_channels, out_channels) {
    self$conv <- nn_conv2d(
      in_channels = in_channels, 
      out_channels = out_channels, 
      kernel_size = c(3,3), 
      padding = "same"
    )
    self$relu <- nn_relu()
    self$pool <- nn_max_pool2d(kernel_size = c(2,2))
  },
  forward = function(x) {
    x |> 
      self$conv() |> 
      self$relu() |> 
      self$pool()
  }
)
```

## Model


```{r}
model <- nn_module(
  initialize = function() {
    self$conv <- nn_sequential(
      conv_block(3, 8),
      conv_block(8, 16)
    )
    self$output <- nn_sequential(
      nn_dropout(0.5),
      nn_linear(1024, 16),
      nn_relu(),
      nn_linear(16, 10)
    )
  },
  forward = function(x) {
    x %>% 
      self$conv() |> 
      torch_flatten(start_dim = 2) |> 
      self$output()
  }
)
```

## Fitting Model


```{r}
fitted <- model |> 
  setup(
    loss = nn_cross_entropy_loss(),
    optimizer = optim_rmsprop, 
  ) |> 
  set_opt_hparams(lr = 0.001) |> 
  fit(
    train_dl,
    epochs = 3
  )
```